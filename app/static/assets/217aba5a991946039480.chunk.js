"use strict";(globalThis.webpackChunksuperset=globalThis.webpackChunksuperset||[]).push([[7024],{531:(e,t,n)=>{n.d(t,{V:()=>m});var s=n(63320);function i(e,t,n){return e.createFramebuffer({width:t,height:n,colorAttachments:[e.createTexture({width:t,height:n,format:"rgba32float",mipmaps:!1,sampler:{minFilter:"nearest",magFilter:"nearest"}})]})}const r={name:"binSorter",vs:"uniform binSorterUniforms {\n  ivec4 binIdRange;\n  ivec2 targetSize;\n} binSorter;\n",uniformTypes:{binIdRange:"vec4<i32>",targetSize:"vec2<i32>"}},o=[1,2,4,8],a=3e38,l={SUM:0,MEAN:0,MIN:0,MAX:0,COUNT:0},u=1024;class d{constructor(e,t){this.binsFBO=null,this.device=e,this.model=function(e,t){let n=t.vs;2===t.dimensions&&(n+="\nvoid getBin(out int binId) {\n  ivec2 binId2;\n  getBin(binId2);\n  if (binId2.x < binSorter.binIdRange.x || binId2.x >= binSorter.binIdRange.y) {\n    binId = -1;\n  } else {\n    binId = (binId2.y - binSorter.binIdRange.z) * (binSorter.binIdRange.y - binSorter.binIdRange.x) + binId2.x;\n  }\n}\n");const i=`#version 300 es\n#define SHADER_NAME gpu-aggregation-sort-bins-vertex\n\n${n}\n\nout vec3 v_Value;\n\nvoid main() {\n  int binIndex;\n  getBin(binIndex);\n  binIndex = binIndex - binSorter.binIdRange.x;\n  if (binIndex < 0) {\n    gl_Position = vec4(0.);\n    return;\n  }\n  int row = binIndex / binSorter.targetSize.x;\n  int col = binIndex - row * binSorter.targetSize.x;\n  vec2 position = (vec2(col, row) + 0.5) / vec2(binSorter.targetSize) * 2.0 - 1.0;\n  gl_Position = vec4(position, 0.0, 1.0);\n  gl_PointSize = 1.0;\n\n#if NUM_CHANNELS == 3\n  getValue(v_Value);\n#elif NUM_CHANNELS == 2\n  getValue(v_Value.xy);\n#else\n  getValue(v_Value.x);\n#endif\n}\n`;return new s.K(e,{bufferLayout:t.bufferLayout,modules:[...t.modules||[],r],defines:{...t.defines,NON_INSTANCED_MODEL:1,NUM_CHANNELS:t.channelCount},isInstanced:!1,vs:i,fs:"#version 300 es\n#define SHADER_NAME gpu-aggregation-sort-bins-fragment\n\nprecision highp float;\n\nin vec3 v_Value;\nout vec4 fragColor;\n\nvoid main() {\n  fragColor.xyz = v_Value;\n\n  #ifdef MODULE_GEOMETRY\n  geometry.uv = vec2(0.);\n  DECKGL_FILTER_COLOR(fragColor, geometry);\n  #endif\n\n  fragColor.w = 1.0;\n}\n",topology:"point-list",disableWarnings:!0})}(e,t)}get texture(){return this.binsFBO?this.binsFBO.colorAttachments[0].texture:null}destroy(){var e,t;this.model.destroy(),null==(e=this.binsFBO)||e.colorAttachments[0].texture.destroy(),null==(t=this.binsFBO)||t.destroy()}getBinValues(e){if(!this.binsFBO)return null;const t=e%u,n=Math.floor(e/u),s=this.device.readPixelsToArrayWebGL(this.binsFBO,{sourceX:t,sourceY:n,sourceWidth:1,sourceHeight:1}).buffer;return new Float32Array(s)}setDimensions(e,t){var n,s;const r=u,o=Math.ceil(e/r);this.binsFBO?this.binsFBO.height<o&&this.binsFBO.resize({width:r,height:o}):this.binsFBO=i(this.device,r,o);const a={binIdRange:[t[0][0],t[0][1],(null==(n=t[1])?void 0:n[0])||0,(null==(s=t[1])?void 0:s[1])||0],targetSize:[this.binsFBO.width,this.binsFBO.height]};this.model.shaderInputs.setProps({binSorter:a})}setModelProps(e){const t=this.model;e.attributes&&t.setAttributes(e.attributes),e.constantAttributes&&t.setConstantAttributes(e.constantAttributes),void 0!==e.vertexCount&&t.setVertexCount(e.vertexCount),e.shaderModuleProps&&t.shaderInputs.setProps(e.shaderModuleProps)}update(e){if(!this.binsFBO)return;const t=function(e){const t={...l};for(let n=0;n<e.length;n++){const s=e[n];s&&(t[s]+=o[n])}return t}(e);this._updateBins("SUM",t.SUM+t.MEAN),this._updateBins("MIN",t.MIN),this._updateBins("MAX",t.MAX)}_updateBins(e,t){if(0===t)return;t|=o[3];const n=this.model,s=this.binsFBO,i="MAX"===e?-a:"MIN"===e?a:0,r=this.device.beginRenderPass({id:`gpu-aggregation-${e}`,framebuffer:s,parameters:{viewport:[0,0,s.width,s.height],colorMask:t},clearColor:[i,i,i,0],clearDepth:!1,clearStencil:!1});n.setParameters({blend:!0,blendColorSrcFactor:"one",blendColorDstFactor:"one",blendAlphaSrcFactor:"one",blendAlphaDstFactor:"one",blendColorOperation:"MAX"===e?"max":"MIN"===e?"min":"add",blendAlphaOperation:"add"}),n.draw(r),r.end()}}var h=n(49676),f=n(65019);class g{static isSupported(e){var t;return"webgl"===(null==e||null==(t=e.info)?void 0:t.type)}constructor(e,t=g.defaultProps){if(this.device=void 0,this.model=void 0,this.transformFeedback=void 0,!g.isSupported(e))throw new Error("BufferTransform not yet implemented on WebGPU");this.device=e,this.model=new s.K(this.device,{id:t.id||"buffer-transform-model",fs:t.fs||(0,f.Wk)(),topology:t.topology||"point-list",varyings:t.outputs||t.varyings,...t}),this.transformFeedback=this.device.createTransformFeedback({layout:this.model.pipeline.shaderLayout,buffers:t.feedbackBuffers}),this.model.setTransformFeedback(this.transformFeedback),Object.seal(this)}destroy(){this.model&&this.model.destroy()}delete(){this.destroy()}run(e){null!=e&&e.inputBuffers&&this.model.setAttributes(e.inputBuffers),null!=e&&e.outputBuffers&&this.transformFeedback.setBuffers(e.outputBuffers);const t=this.device.beginRenderPass(e);this.model.draw(t),t.end()}getBuffer(e){return this.transformFeedback.getBuffer(e)}readAsync(e){const t=this.getBuffer(e);if(!t)throw new Error("BufferTransform#getBuffer");if(t instanceof h.h)return t.readAsync();const{buffer:n,byteOffset:s=0,byteLength:i=n.byteLength}=t;return n.readAsync(s,i)}}g.defaultProps={...s.K.defaultProps,outputs:void 0,feedbackBuffers:void 0};const c={name:"aggregatorTransform",vs:"uniform aggregatorTransformUniforms {\n  ivec4 binIdRange;\n  bvec3 isCount;\n  bvec3 isMean;\n  float naN;\n} aggregatorTransform;\n",uniformTypes:{binIdRange:"vec4<i32>",isCount:"vec3<f32>",isMean:"vec3<f32>"}};class p{constructor(e,t){this.binBuffer=null,this.valueBuffer=null,this._domains=null,this.device=e,this.channelCount=t.channelCount,this.transform=function(e,t){return new g(e,{vs:"#version 300 es\n#define SHADER_NAME gpu-aggregation-domain-vertex\n\nuniform sampler2D bins;\n\n#if NUM_DIMS == 1\nout float binIds;\n#else\nout vec2 binIds;\n#endif\n\n#if NUM_CHANNELS == 1\nflat out float values;\n#elif NUM_CHANNELS == 2\nflat out vec2 values;\n#else\nflat out vec3 values;\n#endif\n\nconst float NAN = intBitsToFloat(-1);\n\nvoid main() {\n  int row = gl_VertexID / SAMPLER_WIDTH;\n  int col = gl_VertexID - row * SAMPLER_WIDTH;\n  vec4 weights = texelFetch(bins, ivec2(col, row), 0);\n  vec3 value3 = mix(\n    mix(weights.rgb, vec3(weights.a), aggregatorTransform.isCount),\n    weights.rgb / max(weights.a, 1.0),\n    aggregatorTransform.isMean\n  );\n  if (weights.a == 0.0) {\n    value3 = vec3(NAN);\n  }\n\n#if NUM_DIMS == 1\n  binIds = float(gl_VertexID + aggregatorTransform.binIdRange.x);\n#else\n  int y = gl_VertexID / (aggregatorTransform.binIdRange.y - aggregatorTransform.binIdRange.x);\n  int x = gl_VertexID - y * (aggregatorTransform.binIdRange.y - aggregatorTransform.binIdRange.x);\n  binIds.y = float(y + aggregatorTransform.binIdRange.z);\n  binIds.x = float(x + aggregatorTransform.binIdRange.x);\n#endif\n\n#if NUM_CHANNELS == 3\n  values = value3;\n#elif NUM_CHANNELS == 2\n  values = value3.xy;\n#else\n  values = value3.x;\n#endif\n\n  gl_Position = vec4(0., 0., 0., 1.);\n  // This model renders into a 2x1 texture to obtain min and max simultaneously.\n  // See comments in fragment shader\n  gl_PointSize = 2.0;\n}\n",fs:"#version 300 es\n#define SHADER_NAME gpu-aggregation-domain-fragment\n\nprecision highp float;\n\n#if NUM_CHANNELS == 1\nflat in float values;\n#elif NUM_CHANNELS == 2\nflat in vec2 values;\n#else\nflat in vec3 values;\n#endif\n\nout vec4 fragColor;\n\nvoid main() {\n  vec3 value3;\n#if NUM_CHANNELS == 3\n  value3 = values;\n#elif NUM_CHANNELS == 2\n  value3.xy = values;\n#else\n  value3.x = values;\n#endif\n  if (isnan(value3.x)) discard;\n  // This shader renders into a 2x1 texture with blending=max\n  // The left pixel yields the max value of each channel\n  // The right pixel yields the min value of each channel\n  if (gl_FragCoord.x < 1.0) {\n    fragColor = vec4(value3, 1.0);\n  } else {\n    fragColor = vec4(-value3, 1.0);\n  }\n}\n",topology:"point-list",modules:[c],parameters:{blend:!0,blendColorSrcFactor:"one",blendColorDstFactor:"one",blendColorOperation:"max",blendAlphaSrcFactor:"one",blendAlphaDstFactor:"one",blendAlphaOperation:"max"},defines:{NUM_DIMS:t.dimensions,NUM_CHANNELS:t.channelCount,SAMPLER_WIDTH:u},varyings:["binIds","values"],disableWarnings:!0})}(e,t),this.domainFBO=i(e,2,1)}destroy(){var e,t;this.transform.destroy(),null==(e=this.binBuffer)||e.destroy(),null==(t=this.valueBuffer)||t.destroy(),this.domainFBO.colorAttachments[0].texture.destroy(),this.domainFBO.destroy()}get domains(){if(!this._domains){const e=this.device.readPixelsToArrayWebGL(this.domainFBO).buffer,t=new Float32Array(e);this._domains=[[-t[4],t[0]],[-t[5],t[1]],[-t[6],t[2]]].slice(0,this.channelCount)}return this._domains}setDimensions(e,t){var n,s;const{model:i,transformFeedback:r}=this.transform;i.setVertexCount(e);const o={binIdRange:[t[0][0],t[0][1],(null==(n=t[1])?void 0:n[0])||0,(null==(s=t[1])?void 0:s[1])||0]};i.shaderInputs.setProps({aggregatorTransform:o});const a=e*t.length*4;var l;(!this.binBuffer||this.binBuffer.byteLength<a)&&(null==(l=this.binBuffer)||l.destroy(),this.binBuffer=this.device.createBuffer({byteLength:a}),r.setBuffer("binIds",this.binBuffer));const u=e*this.channelCount*4;var d;(!this.valueBuffer||this.valueBuffer.byteLength<u)&&(null==(d=this.valueBuffer)||d.destroy(),this.valueBuffer=this.device.createBuffer({byteLength:u}),r.setBuffer("values",this.valueBuffer))}update(e,t){if(!e)return;const n=this.transform,s=this.domainFBO,i={isCount:[0,1,2].map(e=>"COUNT"===t[e]?1:0),isMean:[0,1,2].map(e=>"MEAN"===t[e]?1:0),bins:e};n.model.shaderInputs.setProps({aggregatorTransform:i}),n.run({id:"gpu-aggregation-domain",framebuffer:s,parameters:{viewport:[0,0,2,1]},clearColor:[-3e38,-3e38,-3e38,0],clearDepth:!1,clearStencil:!1}),this._domains=null}}var b=n(89877),v=n(48186);class m{static isSupported(e){return e.features.has("float32-renderable-webgl")&&e.features.has("texture-blend-float-webgl")}constructor(e,t){this.binCount=0,this.binIds=null,this.results=[],this.device=e,this.dimensions=t.dimensions,this.channelCount=t.channelCount,this.props={...t,pointCount:0,binIdRange:[[0,0]],operations:[],attributes:{},binOptions:{}},this.needsUpdate=new Array(this.channelCount).fill(!0),this.binSorter=new d(e,t),this.aggregationTransform=new p(e,t),this.setProps(t)}getBins(){var e;const t=this.aggregationTransform.binBuffer;return t?((null==(e=this.binIds)?void 0:e.buffer)!==t&&(this.binIds={buffer:t,type:"float32",size:this.dimensions}),this.binIds):null}getResult(e){var t;const n=this.aggregationTransform.valueBuffer;return!n||e>=this.channelCount?null:((null==(t=this.results[e])?void 0:t.buffer)!==n&&(this.results[e]={buffer:n,type:"float32",size:1,stride:4*this.channelCount,offset:4*e}),this.results[e])}getResultDomain(e){return this.aggregationTransform.domains[e]}getBin(e){if(e<0||e>=this.binCount)return null;const{binIdRange:t}=this.props;let n;if(1===this.dimensions)n=[e+t[0][0]];else{const[[s,i],[r]]=t,o=i-s;n=[e%o+s,Math.floor(e/o)+r]}const s=this.binSorter.getBinValues(e);if(!s)return null;const i=s[3],r=[];for(let e=0;e<this.channelCount;e++){const t=this.props.operations[e];r[e]="COUNT"===t?i:0===i?NaN:"MEAN"===t?s[e]/i:s[e]}return{id:n,value:r,count:i}}destroy(){this.binSorter.destroy(),this.aggregationTransform.destroy()}setProps(e){const t=this.props;if("binIdRange"in e&&!(0,b.b)(e.binIdRange,t.binIdRange,2)){const t=e.binIdRange;if(v.A.assert(t.length===this.dimensions),1===this.dimensions){const[[e,n]]=t;this.binCount=n-e}else{const[[e,n],[s,i]]=t;this.binCount=(n-e)*(i-s)}this.binSorter.setDimensions(this.binCount,t),this.aggregationTransform.setDimensions(this.binCount,t),this.setNeedsUpdate()}if(e.operations)for(let n=0;n<this.channelCount;n++)e.operations[n]!==t.operations[n]&&this.setNeedsUpdate(n);if(void 0!==e.pointCount&&e.pointCount!==t.pointCount&&(this.binSorter.setModelProps({vertexCount:e.pointCount}),this.setNeedsUpdate()),e.binOptions&&((0,b.b)(e.binOptions,t.binOptions,2)||this.setNeedsUpdate(),this.binSorter.model.shaderInputs.setProps({binOptions:e.binOptions})),e.attributes){const t={},n={};for(const s of Object.values(e.attributes))for(const[e,i]of Object.entries(s.getValue()))ArrayBuffer.isView(i)?n[e]=i:i&&(t[e]=i);this.binSorter.setModelProps({attributes:t,constantAttributes:n})}e.shaderModuleProps&&this.binSorter.setModelProps({shaderModuleProps:e.shaderModuleProps}),Object.assign(this.props,e)}setNeedsUpdate(e){void 0===e?this.needsUpdate.fill(!0):this.needsUpdate[e]=!0}update(){}preDraw(){if(!this.needsUpdate.some(Boolean))return;const{operations:e}=this.props,t=this.needsUpdate.map((t,n)=>t?e[n]:null);this.binSorter.update(t),this.aggregationTransform.update(this.binSorter.texture,e);for(let e=0;e<this.channelCount;e++){var n,s;this.needsUpdate[e]&&(this.needsUpdate[e]=!1,null==(n=(s=this.props).onUpdate)||n.call(s,{channel:e}))}}}},5855:(e,t,n)=>{n.d(t,{M:()=>u});var s=n(89877);const i=(e,t)=>{let n=0;for(const s of e)n+=t(s);return n},r={COUNT:e=>e.length,SUM:i,MEAN:(e,t)=>0===e.length?NaN:i(e,t)/e.length,MIN:(e,t)=>{let n=1/0;for(const s of e){const e=t(s);e<n&&(n=e)}return n},MAX:(e,t)=>{let n=-1/0;for(const s of e){const e=t(s);e>n&&(n=e)}return n}};function o({bins:e,getValue:t,operation:n,target:s}){(!s||s.length<e.length)&&(s=new Float32Array(e.length));let i=1/0,r=-1/0;for(let o=0;o<e.length;o++){const{points:a}=e[o];s[o]=n(a,t),s[o]<i&&(i=s[o]),s[o]>r&&(r=s[o])}return{value:s,domain:[i,r]}}function a(e,t,n){const s={};for(const n of e.sources||[]){const e=t[n];if(!e)throw new Error(`Cannot find attribute ${n}`);s[n]=l(e)}const i={};return t=>{for(const e in s)i[e]=s[e](t);return e.getValue(i,t,n)}}function l(e){const t=e.value,{offset:n=0,stride:s,size:i}=e.getAccessor(),r=t.BYTES_PER_ELEMENT,o=n/r,a=s?s/r:i;if(1===i)return e.isConstant?()=>t[0]:e=>t[o+a*e];let l;return e.isConstant?(l=Array.from(t),()=>l):(l=new Array(i),e=>{const n=o+a*e;for(let e=0;e<i;e++)l[e]=t[n+e];return l})}class u{constructor(e){this.bins=[],this.binIds=null,this.results=[],this.dimensions=e.dimensions,this.channelCount=e.getValue.length,this.props={...e,binOptions:{},pointCount:0,operations:[],customOperations:[],attributes:{}},this.needsUpdate=!0,this.setProps(e)}destroy(){}get binCount(){return this.bins.length}setProps(e){const t=this.props;if(e.binOptions&&((0,s.b)(e.binOptions,t.binOptions,2)||this.setNeedsUpdate()),e.operations)for(let n=0;n<this.channelCount;n++)e.operations[n]!==t.operations[n]&&this.setNeedsUpdate(n);if(e.customOperations)for(let n=0;n<this.channelCount;n++)Boolean(e.customOperations[n])!==Boolean(t.customOperations[n])&&this.setNeedsUpdate(n);void 0!==e.pointCount&&e.pointCount!==t.pointCount&&this.setNeedsUpdate(),e.attributes&&(e.attributes={...t.attributes,...e.attributes}),Object.assign(this.props,e)}setNeedsUpdate(e){void 0===e?this.needsUpdate=!0:!0!==this.needsUpdate&&(this.needsUpdate=this.needsUpdate||[],this.needsUpdate[e]=!0)}update(){if(!0===this.needsUpdate){var e;this.bins=function({pointCount:e,getBinId:t}){const n=new Map;for(let s=0;s<e;s++){const e=t(s);if(null===e)continue;let i=n.get(String(e));i?i.points.push(s):(i={id:e,index:n.size,points:[s]},n.set(String(e),i))}return Array.from(n.values())}({pointCount:this.props.pointCount,getBinId:a(this.props.getBin,this.props.attributes,this.props.binOptions)});const t=function({bins:e,dimensions:t,target:n}){const s=e.length*t;(!n||n.length<s)&&(n=new Float32Array(s));for(let s=0;s<e.length;s++){const{id:i}=e[s];Array.isArray(i)?n.set(i,s*t):n[s]=i}return n}({bins:this.bins,dimensions:this.dimensions,target:null==(e=this.binIds)?void 0:e.value});this.binIds={value:t,type:"float32",size:this.dimensions}}for(let e=0;e<this.channelCount;e++)if(!0===this.needsUpdate||this.needsUpdate[e]){var t,n,s;const i=this.props.customOperations[e]||r[this.props.operations[e]],{value:l,domain:u}=o({bins:this.bins,getValue:a(this.props.getValue[e],this.props.attributes,void 0),operation:i,target:null==(t=this.results[e])?void 0:t.value});this.results[e]={value:l,domain:u,type:"float32",size:1},null==(n=(s=this.props).onUpdate)||n.call(s,{channel:e})}this.needsUpdate=!1}preDraw(){}getBins(){return this.binIds}getResult(e){return this.results[e]}getResultDomain(e){var t,n;return null!=(t=null==(n=this.results[e])?void 0:n.domain)?t:[1/0,-1/0]}getBin(e){const t=this.bins[e];if(!t)return null;const n=new Array(this.channelCount);for(let t=0;t<n.length;t++){const s=this.results[t];n[t]=null==s?void 0:s.value[e]}return{id:t.id,value:n,count:t.points.length,pointIndices:t.points}}}},53112:(e,t,n)=>{n.d(t,{A:()=>o});var s=n(76856),i=n(71677);class r extends i.A{get isDrawable(){return!0}initializeState(){this.getAttributeManager().remove(["instancePickingColors"])}updateState(e){super.updateState(e);const t=this.getAggregatorType();if(e.changeFlags.extensionsChanged||this.state.aggregatorType!==t){var n,s;null==(n=this.state.aggregator)||n.destroy();const e=this.createAggregator(t);return e.setProps({attributes:null==(s=this.getAttributeManager())?void 0:s.attributes}),this.setState({aggregator:e,aggregatorType:t}),!0}return!1}finalizeState(e){super.finalizeState(e),this.state.aggregator.destroy()}updateAttributes(e){const{aggregator:t}=this.state;t.setProps({attributes:e});for(const t in e)this.onAttributeChange(t);t.update()}draw({shaderModuleProps:e}){const{aggregator:t}=this.state;t.setProps({shaderModuleProps:e}),t.preDraw()}_getAttributeManager(){return new s.A(this.context.device,{id:this.props.id,stats:this.context.stats})}}r.layerName="AggregationLayer";const o=r}}]);