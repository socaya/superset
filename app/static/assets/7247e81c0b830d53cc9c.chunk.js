"use strict";(globalThis.webpackChunksuperset=globalThis.webpackChunksuperset||[]).push([[1740],{20272:(e,t,o)=>{o.d(t,{V:()=>n});var i=o(11173);class n{constructor(e){this.id=void 0,this.topology=void 0,this.vertexCount=void 0,this.indices=void 0,this.attributes=void 0,this.userData={};const{attributes:t={},indices:o=null,vertexCount:n=null}=e;this.id=e.id||(0,i.L)("geometry"),this.topology=e.topology,o&&(this.indices=ArrayBuffer.isView(o)?{value:o,size:1}:o),this.attributes={};for(const[e,o]of Object.entries(t)){const t=ArrayBuffer.isView(o)?{value:o}:o;if(!ArrayBuffer.isView(t.value))throw new Error(`${this._print(e)}: must be typed array or object with value as typed array`);if("POSITION"!==e&&"positions"!==e||t.size||(t.size=3),"indices"===e){if(this.indices)throw new Error("Multiple indices detected");this.indices=t}else this.attributes[e]=t}this.indices&&void 0!==this.indices.isIndexed&&(this.indices=Object.assign({},this.indices),delete this.indices.isIndexed),this.vertexCount=n||this._calculateVertexCount(this.attributes,this.indices)}getVertexCount(){return this.vertexCount}getAttributes(){return this.indices?{indices:this.indices,...this.attributes}:this.attributes}_print(e){return`Geometry ${this.id} attribute ${e}`}_setAttributes(e,t){return this}_calculateVertexCount(e,t){if(t)return t.value.length;let o=1/0;for(const t of Object.values(e)){const{value:e,size:i,constant:n}=t;!n&&e&&void 0!==i&&i>=1&&(o=Math.min(o,e.length/i))}return o}}},31740:(e,t,o)=>{o.d(t,{A:()=>E});var i=o(48186),n=o(38706),a=o(37604),r=o(26630),s=o(531),l=o(5855),c=o(53112),g=o(78579),u=o(92518),d=o(4291),p=o(52208),m=o(20272),v=o(11173);class h extends m.V{constructor(e={}){const{id:t=(0,v.L)("cube-geometry"),indices:o=!0}=e;super(o?{...e,id:t,topology:"triangle-list",indices:{size:1,value:C},attributes:{...V,...e.attributes}}:{...e,id:t,topology:"triangle-list",indices:void 0,attributes:{...A,...e.attributes}})}}const C=new Uint16Array([0,1,2,0,2,3,4,5,6,4,6,7,8,9,10,8,10,11,12,13,14,12,14,15,16,17,18,16,18,19,20,21,22,20,22,23]),y=new Float32Array([-1,-1,1,1,-1,1,1,1,1,-1,1,1,-1,-1,-1,-1,1,-1,1,1,-1,1,-1,-1,-1,1,-1,-1,1,1,1,1,1,1,1,-1,-1,-1,-1,1,-1,-1,1,-1,1,-1,-1,1,1,-1,-1,1,1,-1,1,1,1,1,-1,1,-1,-1,-1,-1,-1,1,-1,1,1,-1,1,-1]),f=new Float32Array([0,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0]),b=new Float32Array([0,0,1,0,1,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,1,0,1,1,1,1,0,1,0,0,1,0,1,0,1,1,0,1,0,0,0,0,1,0,1,1,0,1]),S=new Float32Array([1,-1,1,-1,-1,1,-1,-1,-1,1,-1,-1,1,-1,1,-1,-1,-1,1,1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,1,-1,-1,-1,1,1,1,1,1,1,1,-1,-1,1,-1,-1,1,1,1,1,-1,-1,-1,1,-1,1,1,-1,1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,1,1,1,-1,1,1,-1,-1,1,-1,-1,1,1,-1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,1,-1,1,1,-1,1,-1,-1,-1,1,-1]),x=new Float32Array([1,1,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,0,0,1,0,1,1,0,0]),z=new Float32Array([1,0,1,1,0,0,1,1,0,0,0,1,1,0,0,1,1,0,1,1,0,0,0,1,1,1,1,1,1,0,1,1,1,0,0,1,1,1,0,1,1,1,1,1,1,0,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,1,0,1,0,1,1,1,1,1,0,1,0,0,1,1,0,1,1,1,0,1,0,1,0,0,0,1,0,0,1,1,0,1,0,1,1,1,1,1,0,1,1,1,0,0,1,1,0,0,1,1,1,0,1,1,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0,1,1,1,0,1,1,0,0,1,0,1,0,1]),V={POSITION:{size:3,value:y},NORMAL:{size:3,value:f},TEXCOORD_0:{size:2,value:b}},A={POSITION:{size:3,value:S},TEXCOORD_0:{size:2,value:x},COLOR_0:{size:3,value:z}},P={name:"grid",vs:"uniform gridUniforms {\n  vec4 colorDomain;\n  vec4 elevationDomain;\n  vec2 elevationRange;\n  vec2 originCommon;\n  vec2 sizeCommon;\n} grid;\n",uniformTypes:{colorDomain:"vec4<f32>",elevationDomain:"vec4<f32>",elevationRange:"vec2<f32>",originCommon:"vec2<f32>",sizeCommon:"vec2<f32>"}};class w extends p.A{getShaders(){const e=super.getShaders();return e.modules.push(P),{...e,vs:"#version 300 es\n#define SHADER_NAME grid-cell-layer-vertex-shader\nin vec3 positions;\nin vec3 normals;\nin vec2 instancePositions;\nin float instanceElevationValues;\nin float instanceColorValues;\nin vec3 instancePickingColors;\nuniform sampler2D colorRange;\nout vec4 vColor;\nfloat interp(float value, vec2 domain, vec2 range) {\nfloat r = min(max((value - domain.x) / (domain.y - domain.x), 0.), 1.);\nreturn mix(range.x, range.y, r);\n}\nvec4 interp(float value, vec2 domain, sampler2D range) {\nfloat r = (value - domain.x) / (domain.y - domain.x);\nreturn texture(range, vec2(r, 0.5));\n}\nvoid main(void) {\ngeometry.pickingColor = instancePickingColors;\nif (isnan(instanceColorValues) ||\ninstanceColorValues < grid.colorDomain.z ||\ninstanceColorValues > grid.colorDomain.w ||\ninstanceElevationValues < grid.elevationDomain.z ||\ninstanceElevationValues > grid.elevationDomain.w\n) {\ngl_Position = vec4(0.);\nreturn;\n}\nvec2 commonPosition = (instancePositions + (positions.xy + 1.0) / 2.0 * column.coverage) * grid.sizeCommon + grid.originCommon - project.commonOrigin.xy;\ngeometry.position = vec4(commonPosition, 0.0, 1.0);\ngeometry.normal = project_normal(normals);\nfloat elevation = 0.0;\nif (column.extruded) {\nelevation = interp(instanceElevationValues, grid.elevationDomain.xy, grid.elevationRange);\nelevation = project_size(elevation);\ngeometry.position.z = (positions.z + 1.0) / 2.0 * elevation;\n}\ngl_Position = project_common_position_to_clipspace(geometry.position);\nDECKGL_FILTER_GL_POSITION(gl_Position, geometry);\nvColor = interp(instanceColorValues, grid.colorDomain.xy, colorRange);\nvColor.a *= layer.opacity;\nif (column.extruded) {\nvColor.rgb = lighting_getLightColor(vColor.rgb, project.cameraPosition, geometry.position.xyz, geometry.normal);\n}\nDECKGL_FILTER_COLOR(vColor, geometry);\n}\n"}}initializeState(){super.initializeState();const e=this.getAttributeManager();e.remove(["instanceElevations","instanceFillColors","instanceLineColors","instanceStrokeWidths"]),e.addInstanced({instancePositions:{size:2,type:"float32",accessor:"getBin"},instanceColorValues:{size:1,type:"float32",accessor:"getColorValue"},instanceElevationValues:{size:1,type:"float32",accessor:"getElevationValue"}})}updateState(e){super.updateState(e);const{props:t,oldProps:o}=e,i=this.state.fillModel;if(o.colorRange!==t.colorRange){var n;null==(n=this.state.colorTexture)||n.destroy(),this.state.colorTexture=(0,g.cp)(this.context.device,t.colorRange,t.colorScaleType);const e={colorRange:this.state.colorTexture};i.shaderInputs.setProps({grid:e})}else o.colorScaleType!==t.colorScaleType&&(0,g.Pu)(this.state.colorTexture,t.colorScaleType)}finalizeState(e){var t;super.finalizeState(e),null==(t=this.state.colorTexture)||t.destroy()}_updateGeometry(){const e=new h;this.state.fillModel.setGeometry(e)}draw({uniforms:e}){const{cellOriginCommon:t,cellSizeCommon:o,elevationRange:i,elevationScale:n,extruded:a,coverage:r,colorDomain:s,elevationDomain:l}=this.props,c=this.props.colorCutoff||[-1/0,1/0],g=this.props.elevationCutoff||[-1/0,1/0],u=this.state.fillModel,d={colorDomain:[Math.max(s[0],c[0]),Math.min(s[1],c[1]),Math.max(s[0]-1,c[0]),Math.min(s[1]+1,c[1])],elevationDomain:[Math.max(l[0],g[0]),Math.min(l[1],g[1]),Math.max(l[0]-1,g[0]),Math.min(l[1]+1,g[1])],elevationRange:[i[0]*n,i[1]*n],originCommon:t,sizeCommon:o};u.shaderInputs.setProps({column:{extruded:a,coverage:r},grid:d}),u.draw(this.context.renderPass)}}w.layerName="GridCellLayer";const O={name:"binOptions",vs:"uniform binOptionsUniforms {\n  vec2 cellOriginCommon;\n  vec2 cellSizeCommon;\n} binOptions;\n",uniformTypes:{cellOriginCommon:"vec2<f32>",cellSizeCommon:"vec2<f32>"}};function D(){}const R={gpuAggregation:!0,colorDomain:null,colorRange:g.QO,getColorValue:{type:"accessor",value:null},getColorWeight:{type:"accessor",value:1},colorAggregation:"SUM",lowerPercentile:{type:"number",min:0,max:100,value:0},upperPercentile:{type:"number",min:0,max:100,value:100},colorScaleType:"quantize",onSetColorDomain:D,elevationDomain:null,elevationRange:[0,1e3],getElevationValue:{type:"accessor",value:null},getElevationWeight:{type:"accessor",value:1},elevationAggregation:"SUM",elevationScale:{type:"number",min:0,value:1},elevationLowerPercentile:{type:"number",min:0,max:100,value:0},elevationUpperPercentile:{type:"number",min:0,max:100,value:100},elevationScaleType:"linear",onSetElevationDomain:D,cellSize:{type:"number",min:0,value:1e3},coverage:{type:"number",min:0,max:1,value:1},getPosition:{type:"accessor",value:e=>e.position},gridAggregator:{type:"function",optional:!0,value:null},extruded:!1,material:!0};class T extends c.A{getAggregatorType(){const{gpuAggregation:e,gridAggregator:t,getColorValue:o,getElevationValue:n}=this.props;return e&&(t||o||n)?(i.A.warn("Features not supported by GPU aggregation, falling back to CPU")(),"cpu"):e&&s.V.isSupported(this.context.device)?"gpu":"cpu"}createAggregator(e){if("cpu"===e){const{gridAggregator:e,cellSize:t}=this.props;return new l.M({dimensions:2,getBin:{sources:["positions"],getValue:({positions:o},i,n)=>{if(e)return e(o,t);const a=this.state.aggregatorViewport.projectPosition(o),{cellSizeCommon:r,cellOriginCommon:s}=n;return[Math.floor((a[0]-s[0])/r[0]),Math.floor((a[1]-s[1])/r[1])]}},getValue:[{sources:["colorWeights"],getValue:({colorWeights:e})=>e},{sources:["elevationWeights"],getValue:({elevationWeights:e})=>e}]})}return new s.V(this.context.device,{dimensions:2,channelCount:2,bufferLayout:this.getAttributeManager().getBufferLayouts({isInstanced:!1}),...super.getShaders({modules:[n.A,O],vs:"\n  in vec3 positions;\n  in vec3 positions64Low;\n  in float colorWeights;\n  in float elevationWeights;\n\n  void getBin(out ivec2 binId) {\n    vec3 positionCommon = project_position(positions, positions64Low);\n    vec2 gridCoords = floor(positionCommon.xy / binOptions.cellSizeCommon);\n    binId = ivec2(gridCoords);\n  }\n  void getValue(out vec2 value) {\n    value = vec2(colorWeights, elevationWeights);\n  }\n  "})})}initializeState(){super.initializeState(),this.getAttributeManager().add({positions:{size:3,accessor:"getPosition",type:"float64",fp64:this.use64bitPositions()},colorWeights:{size:1,accessor:"getColorWeight"},elevationWeights:{size:1,accessor:"getElevationWeight"}})}updateState(e){const t=super.updateState(e),{props:o,oldProps:i,changeFlags:n}=e,{aggregator:r}=this.state;if(!n.dataChanged&&this.state.dataAsArray||!o.getColorValue&&!o.getElevationValue||(this.state.dataAsArray=Array.from((0,a.X)(o.data).iterable)),t||n.dataChanged||o.cellSize!==i.cellSize||o.getColorValue!==i.getColorValue||o.getElevationValue!==i.getElevationValue||o.colorAggregation!==i.colorAggregation||o.elevationAggregation!==i.elevationAggregation){this._updateBinOptions();const{cellSizeCommon:e,cellOriginCommon:t,binIdRange:i,dataAsArray:n}=this.state;if(r.setProps({binIdRange:i,pointCount:this.getNumInstances(),operations:[o.colorAggregation,o.elevationAggregation],binOptions:{cellSizeCommon:e,cellOriginCommon:t},onUpdate:this._onAggregationUpdate.bind(this)}),n){const{getColorValue:e,getElevationValue:t}=this.props;r.setProps({customOperations:[e&&(t=>e(t.map(e=>n[e]),{indices:t,data:o.data})),t&&(e=>t(e.map(e=>n[e]),{indices:e,data:o.data}))]})}}return n.updateTriggersChanged&&n.updateTriggersChanged.getColorValue&&r.setNeedsUpdate(0),n.updateTriggersChanged&&n.updateTriggersChanged.getElevationValue&&r.setNeedsUpdate(1),t}_updateBinOptions(){const e=this.getBounds(),t=[1,1];let o=[0,0],i=[[0,1],[0,1]],n=this.context.viewport;if(e&&Number.isFinite(e[0][0])){let a=[(e[0][0]+e[1][0])/2,(e[0][1]+e[1][1])/2];const{cellSize:s}=this.props,{unitsPerMeter:l}=n.getDistanceScales(a);t[0]=l[0]*s,t[1]=l[1]*s;const c=n.projectFlat(a);o=[Math.floor(c[0]/t[0])*t[0],Math.floor(c[1]/t[1])*t[1]],a=n.unprojectFlat(o);const g=n.constructor;n=n.isGeospatial?new g({longitude:a[0],latitude:a[1],zoom:12}):new r.A({position:[a[0],a[1],0],zoom:12}),o=[Math.fround(n.center[0]),Math.fround(n.center[1])],i=(0,d.O)({dataBounds:e,getBinId:e=>{const i=n.projectFlat(e);return[Math.floor((i[0]-o[0])/t[0]),Math.floor((i[1]-o[1])/t[1])]}})}this.setState({cellSizeCommon:t,cellOriginCommon:o,binIdRange:i,aggregatorViewport:n})}draw(e){e.shaderModuleProps.project&&(e.shaderModuleProps.project.viewport=this.state.aggregatorViewport),super.draw(e)}_onAggregationUpdate({channel:e}){const t=this.getCurrentLayer().props,{aggregator:o}=this.state;if(0===e){const e=o.getResult(0);this.setState({colors:new u.bg(e,o.binCount)}),t.onSetColorDomain(o.getResultDomain(0))}else if(1===e){const e=o.getResult(1);this.setState({elevations:new u.bg(e,o.binCount)}),t.onSetElevationDomain(o.getResultDomain(1))}}onAttributeChange(e){const{aggregator:t}=this.state;switch(e){case"positions":t.setNeedsUpdate(),this._updateBinOptions();const{cellSizeCommon:e,cellOriginCommon:o,binIdRange:i}=this.state;t.setProps({binIdRange:i,binOptions:{cellSizeCommon:e,cellOriginCommon:o}});break;case"colorWeights":t.setNeedsUpdate(0);break;case"elevationWeights":t.setNeedsUpdate(1)}}renderLayers(){var e,t;const{aggregator:o,cellOriginCommon:i,cellSizeCommon:n}=this.state,{elevationScale:a,colorRange:r,elevationRange:s,extruded:l,coverage:c,material:g,transitions:u,colorScaleType:d,lowerPercentile:p,upperPercentile:m,colorDomain:v,elevationScaleType:h,elevationLowerPercentile:C,elevationUpperPercentile:y,elevationDomain:f}=this.props,b=this.getSubLayerClass("cells",w),S=o.getBins(),x=null==(e=this.state.colors)?void 0:e.update({scaleType:d,lowerPercentile:p,upperPercentile:m}),z=null==(t=this.state.elevations)?void 0:t.update({scaleType:h,lowerPercentile:C,upperPercentile:y});return x&&z?new b(this.getSubLayerProps({id:"cells"}),{data:{length:o.binCount,attributes:{getBin:S,getColorValue:x.attribute,getElevationValue:z.attribute}},dataComparator:(e,t)=>e.length===t.length,updateTriggers:{getBin:[S],getColorValue:[x.attribute],getElevationValue:[z.attribute]},cellOriginCommon:i,cellSizeCommon:n,elevationScale:a,colorRange:r,colorScaleType:d,elevationRange:s,extruded:l,coverage:c,material:g,colorDomain:x.domain||v||o.getResultDomain(0),elevationDomain:z.domain||f||o.getResultDomain(1),colorCutoff:x.cutoff,elevationCutoff:z.cutoff,transitions:u&&{getFillColor:u.getColorValue||u.getColorWeight,getElevation:u.getElevationValue||u.getElevationWeight},extensions:[]}):null}getPickingInfo(e){const t=e.info,{index:o}=t;if(o>=0){const e=this.state.aggregator.getBin(o);let i;e&&(i={col:e.id[0],row:e.id[1],colorValue:e.value[0],elevationValue:e.value[1],count:e.count},e.pointIndices&&(i.pointIndices=e.pointIndices,i.points=Array.isArray(this.props.data)?e.pointIndices.map(e=>this.props.data[e]):[])),t.object=i}return t}}T.layerName="GridLayer",T.defaultProps=R;const E=T}}]);