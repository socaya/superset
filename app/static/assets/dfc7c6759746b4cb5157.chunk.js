"use strict";(globalThis.webpackChunksuperset=globalThis.webpackChunksuperset||[]).push([[3374],{832:(t,e,o)=>{o.d(e,{c:()=>S,y:()=>y});var n=o(2404),a=o.n(n),r=o(2445),i=o(24002),s=o(67413),c=o(35942),l=o(14503),u=o(28027),d=o(50871),g=o(98456),p=o(48238),f=o(92123),m=o(51316),h=o(20605);const{getScale:x}=l;function _(t,e){const o=t.color_picker||{r:0,g:0,b:0,a:1},n=[o.r,o.g,o.b,255*o.a],a=t.color_scheme,r=x(a);let i={};return t.color_scheme_type===f.wP.color_breakpoints?i=(0,m.BK)(t.color_breakpoints):e.forEach(e=>{if(null!=e.cat_color&&!i.hasOwnProperty(e.cat_color)){let a;a=t.dimension?(0,d.hexToRGB)(r(e.cat_color,t.sliceId),255*o.a):n,i[e.cat_color]={color:a,enabled:!0}}}),i}const v=t=>{const e=(0,i.useRef)(null),o=(0,i.useCallback)(()=>{let e={...t.viewport};return t.formData.autozoom&&(e=(0,p.A)(e,{width:t.width,height:t.height,points:t.getPoints(t.payload.data.features||[])})),e.zoom<0&&(e.zoom=0),e},[t]),[n,a]=(0,i.useState)(_(t.formData,t.payload.data.features||[])),[s,l]=(0,i.useState)(t.payload.form_data),[m,v]=(0,i.useState)(o());(0,i.useEffect)(()=>{if(t.payload.form_data!==s){const e=t.payload.data.features||[],n=_(t.formData,e);v(o()),l(t.payload.form_data),a(n)}},[o,t,s]);const P=(0,i.useCallback)(t=>{const{current:o}=e;o&&o.setTooltip(t)},[]),y=(0,i.useCallback)((t,e,o)=>{const n=e.color_scheme,a=x(n);let r;switch(o){case f.wP.fixed_color:{r=e.color_picker||{r:0,g:0,b:0,a:100};const o=[r.r,r.g,r.b,255*r.a];return t.map(t=>({...t,color:o}))}case f.wP.categorical_palette:if(!e.dimension){const o=e.color_picker||{r:0,g:0,b:0,a:100},n=[o.r,o.g,o.b,255*o.a];return t.map(t=>({...t,color:n}))}return t.map(t=>({...t,color:(0,d.hexToRGB)(a(t.cat_color,e.slice_id))}));case f.wP.color_breakpoints:{const o=e.default_breakpoint_color?[e.default_breakpoint_color.r,e.default_breakpoint_color.g,e.default_breakpoint_color.b,255*e.default_breakpoint_color.a]:[h.DL.r,h.DL.g,h.DL.b,255*h.DL.a];return t.map(t=>{var n;const a=null==(n=e.color_breakpoints)?void 0:n.find(e=>t.metric>=e.minValue&&t.metric<=e.maxValue);if(a){const e=[a.color.r,a.color.g,a.color.b,255*a.color.a];return{...t,color:e}}return{...t,color:o}})}default:return[]}},[]),S=(0,i.useCallback)(()=>{const{getLayer:e,getHighlightLayer:o,payload:a,formData:r,onAddFilter:i,onContextMenu:s,filterState:c,setDataMask:l,emitCrossFilters:u}=t;let d=a.data.features?[...a.data.features]:[];const p=r.color_scheme_type;d=y(d,r,p),r.js_data_mutator&&(d=(0,g.A)(r.js_data_mutator)(d)),r.dimension&&(d=d.filter(t=>{var e;return null==(e=n[t.cat_color])?void 0:e.enabled}));const f={formData:r,payload:{...a,data:{...a.data,features:d}},onAddFilter:i,setTooltip:P,datasource:t.datasource,onContextMenu:s,filterState:c,setDataMask:l,emitCrossFilters:u},m=e(f);return u&&null!=c&&c.value&&o?[m,o(f)]:[m]},[y,n,t,P]),w=(0,i.useCallback)(t=>{const e=n[t],o={...n,[t]:{...e,enabled:!e.enabled}};Object.values(o).every(t=>!t.enabled)&&Object.values(o).forEach(t=>{t.enabled=!0}),a(o)},[n]),C=(0,i.useCallback)(t=>{const e={...n};Object.values(e).forEach(t=>{t.enabled=!1}),e[t].enabled=!0,a(e)},[n]);return(0,r.FD)("div",{style:{position:"relative"},children:[(0,r.Y)(c.S,{ref:e,viewport:m,layers:S(),setControlValue:t.setControlValue,mapStyle:t.formData.mapbox_style,mapboxApiAccessToken:t.mapboxApiKey,width:t.width,height:t.height}),(0,r.Y)(u.A,{forceCategorical:!0,categories:n,format:t.formData.legend_format,position:t.formData.legend_position,showSingleCategory:C,toggleCategory:w})]})},P=(0,i.memo)(v);function y(t,e,o){return(0,i.memo)(n=>{const l=(0,i.useRef)(),d=(0,s.Z)(n.formData),g=(0,s.Z)(n.filterState),f=(0,s.Z)(n.payload),[h,x]=(0,i.useState)((0,m.BK)(n.formData.color_breakpoints)||[]),[_,v]=(0,i.useState)((()=>{const{width:t,height:o,formData:a}=n;return a.autozoom?(0,p.A)(n.viewport,{width:t,height:o,points:e(n.payload.data.features)}):n.viewport})()),P=(0,i.useCallback)(t=>{const{current:e}=l;e&&(null==e||e.setTooltip(t))},[]),y=(0,i.useCallback)(e=>{const{formData:n,payload:a,onAddFilter:r,filterState:i,setDataMask:s,onContextMenu:c,emitCrossFilters:l}=e,u={formData:n,payload:a,onAddFilter:r,setTooltip:P,setDataMask:s,onContextMenu:c,filterState:i,emitCrossFilters:l},d=t(u);return l&&null!=i&&i.value&&o?[d,o(u)]:[d]},[P]);(0,i.useEffect)(()=>{const t=(0,m.BK)(n.formData.color_breakpoints);x(t)},[n]);const[S,w]=(0,i.useState)(y(n));(0,i.useEffect)(()=>{const t={...d,...g,viewport:null},e={...n.formData,...n.filterState,viewport:null};a()(t,e)&&f===n.payload||w(y(n))},[y,d,g,f,n]);const{formData:C,payload:b,setControlValue:D,height:R,width:T}=n;return(0,r.FD)("div",{style:{position:"relative"},children:[(0,r.Y)(c.S,{ref:l,mapboxApiAccessToken:b.data.mapboxApiKey,viewport:_,layers:S,mapStyle:C.mapbox_style,setControlValue:D,width:T,height:R,onViewportChange:v}),(0,r.Y)(u.A,{forceCategorical:!0,categories:h,format:n.formData.legend_format,position:n.formData.legend_position})]})})}function S(t,e,o){return function(n){const{datasource:a,formData:i,height:s,payload:c,setControlValue:l,viewport:u,width:d,setDataMask:g,filterState:p,onContextMenu:f,emitCrossFilters:m}=n;return(0,r.Y)(P,{datasource:a,formData:i,mapboxApiKey:c.data.mapboxApiKey,setControlValue:l,viewport:u,getLayer:t,getHighlightLayer:o,payload:c,getPoints:e,width:d,height:s,setDataMask:g,onContextMenu:f,filterState:p,emitCrossFilters:m})}}},83374:(t,e,o)=>{o.r(e),o.d(e,{default:()=>C,getHighlightLayer:()=>w,getLayer:()=>S,getPoints:()=>P});var n=o(2445),a=o(15473),r=o(38706),i=o(82849),s=o(59),c=o(60945);const l="uniform arcUniforms {\n  bool greatCircle;\n  bool useShortestPath;\n  float numSegments;\n  float widthScale;\n  float widthMinPixels;\n  float widthMaxPixels;\n  highp int widthUnits;\n} arc;\n",u={name:"arc",vs:l,fs:l,uniformTypes:{greatCircle:"f32",useShortestPath:"f32",numSegments:"f32",widthScale:"f32",widthMinPixels:"f32",widthMaxPixels:"f32",widthUnits:"i32"}},d=[0,0,0,255],g={getSourcePosition:{type:"accessor",value:t=>t.sourcePosition},getTargetPosition:{type:"accessor",value:t=>t.targetPosition},getSourceColor:{type:"accessor",value:d},getTargetColor:{type:"accessor",value:d},getWidth:{type:"accessor",value:1},getHeight:{type:"accessor",value:1},getTilt:{type:"accessor",value:0},greatCircle:!1,numSegments:{type:"number",value:50,min:1},widthUnits:"pixels",widthScale:{type:"number",value:1,min:0},widthMinPixels:{type:"number",value:0,min:0},widthMaxPixels:{type:"number",value:Number.MAX_SAFE_INTEGER,min:0}};class p extends a.A{getBounds(){return this.getAttributeManager()?.getBounds(["instanceSourcePositions","instanceTargetPositions"])}getShaders(){return super.getShaders({vs:"#version 300 es\n#define SHADER_NAME arc-layer-vertex-shader\nin vec4 instanceSourceColors;\nin vec4 instanceTargetColors;\nin vec3 instanceSourcePositions;\nin vec3 instanceSourcePositions64Low;\nin vec3 instanceTargetPositions;\nin vec3 instanceTargetPositions64Low;\nin vec3 instancePickingColors;\nin float instanceWidths;\nin float instanceHeights;\nin float instanceTilts;\nout vec4 vColor;\nout vec2 uv;\nout float isValid;\nfloat paraboloid(float distance, float sourceZ, float targetZ, float ratio) {\nfloat deltaZ = targetZ - sourceZ;\nfloat dh = distance * instanceHeights;\nif (dh == 0.0) {\nreturn sourceZ + deltaZ * ratio;\n}\nfloat unitZ = deltaZ / dh;\nfloat p2 = unitZ * unitZ + 1.0;\nfloat dir = step(deltaZ, 0.0);\nfloat z0 = mix(sourceZ, targetZ, dir);\nfloat r = mix(ratio, 1.0 - ratio, dir);\nreturn sqrt(r * (p2 - r)) * dh + z0;\n}\nvec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction, float width) {\nvec2 dir_screenspace = normalize(line_clipspace * project.viewportSize);\ndir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\nreturn dir_screenspace * offset_direction * width / 2.0;\n}\nfloat getSegmentRatio(float index) {\nreturn smoothstep(0.0, 1.0, index / (arc.numSegments - 1.0));\n}\nvec3 interpolateFlat(vec3 source, vec3 target, float segmentRatio) {\nfloat distance = length(source.xy - target.xy);\nfloat z = paraboloid(distance, source.z, target.z, segmentRatio);\nfloat tiltAngle = radians(instanceTilts);\nvec2 tiltDirection = normalize(target.xy - source.xy);\nvec2 tilt = vec2(-tiltDirection.y, tiltDirection.x) * z * sin(tiltAngle);\nreturn vec3(\nmix(source.xy, target.xy, segmentRatio) + tilt,\nz * cos(tiltAngle)\n);\n}\nfloat getAngularDist (vec2 source, vec2 target) {\nvec2 sourceRadians = radians(source);\nvec2 targetRadians = radians(target);\nvec2 sin_half_delta = sin((sourceRadians - targetRadians) / 2.0);\nvec2 shd_sq = sin_half_delta * sin_half_delta;\nfloat a = shd_sq.y + cos(sourceRadians.y) * cos(targetRadians.y) * shd_sq.x;\nreturn 2.0 * asin(sqrt(a));\n}\nvec3 interpolateGreatCircle(vec3 source, vec3 target, vec3 source3D, vec3 target3D, float angularDist, float t) {\nvec2 lngLat;\nif(abs(angularDist - PI) < 0.001) {\nlngLat = (1.0 - t) * source.xy + t * target.xy;\n} else {\nfloat a = sin((1.0 - t) * angularDist);\nfloat b = sin(t * angularDist);\nvec3 p = source3D.yxz * a + target3D.yxz * b;\nlngLat = degrees(vec2(atan(p.y, -p.x), atan(p.z, length(p.xy))));\n}\nfloat z = paraboloid(angularDist * EARTH_RADIUS, source.z, target.z, t);\nreturn vec3(lngLat, z);\n}\nvoid main(void) {\ngeometry.worldPosition = instanceSourcePositions;\ngeometry.worldPositionAlt = instanceTargetPositions;\nfloat segmentIndex = float(gl_VertexID / 2);\nfloat segmentSide = mod(float(gl_VertexID), 2.) == 0. ? -1. : 1.;\nfloat segmentRatio = getSegmentRatio(segmentIndex);\nfloat prevSegmentRatio = getSegmentRatio(max(0.0, segmentIndex - 1.0));\nfloat nextSegmentRatio = getSegmentRatio(min(arc.numSegments - 1.0, segmentIndex + 1.0));\nfloat indexDir = mix(-1.0, 1.0, step(segmentIndex, 0.0));\nisValid = 1.0;\nuv = vec2(segmentRatio, segmentSide);\ngeometry.uv = uv;\ngeometry.pickingColor = instancePickingColors;\nvec4 curr;\nvec4 next;\nvec3 source;\nvec3 target;\nif ((arc.greatCircle || project.projectionMode == PROJECTION_MODE_GLOBE) && project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {\nsource = project_globe_(vec3(instanceSourcePositions.xy, 0.0));\ntarget = project_globe_(vec3(instanceTargetPositions.xy, 0.0));\nfloat angularDist = getAngularDist(instanceSourcePositions.xy, instanceTargetPositions.xy);\nvec3 prevPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, prevSegmentRatio);\nvec3 currPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, segmentRatio);\nvec3 nextPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, nextSegmentRatio);\nif (abs(currPos.x - prevPos.x) > 180.0) {\nindexDir = -1.0;\nisValid = 0.0;\n} else if (abs(currPos.x - nextPos.x) > 180.0) {\nindexDir = 1.0;\nisValid = 0.0;\n}\nnextPos = indexDir < 0.0 ? prevPos : nextPos;\nnextSegmentRatio = indexDir < 0.0 ? prevSegmentRatio : nextSegmentRatio;\nif (isValid == 0.0) {\nnextPos.x += nextPos.x > 0.0 ? -360.0 : 360.0;\nfloat t = ((currPos.x > 0.0 ? 180.0 : -180.0) - currPos.x) / (nextPos.x - currPos.x);\ncurrPos = mix(currPos, nextPos, t);\nsegmentRatio = mix(segmentRatio, nextSegmentRatio, t);\n}\nvec3 currPos64Low = mix(instanceSourcePositions64Low, instanceTargetPositions64Low, segmentRatio);\nvec3 nextPos64Low = mix(instanceSourcePositions64Low, instanceTargetPositions64Low, nextSegmentRatio);\ncurr = project_position_to_clipspace(currPos, currPos64Low, vec3(0.0), geometry.position);\nnext = project_position_to_clipspace(nextPos, nextPos64Low, vec3(0.0));\n} else {\nvec3 source_world = instanceSourcePositions;\nvec3 target_world = instanceTargetPositions;\nif (arc.useShortestPath) {\nsource_world.x = mod(source_world.x + 180., 360.0) - 180.;\ntarget_world.x = mod(target_world.x + 180., 360.0) - 180.;\nfloat deltaLng = target_world.x - source_world.x;\nif (deltaLng > 180.) target_world.x -= 360.;\nif (deltaLng < -180.) source_world.x -= 360.;\n}\nsource = project_position(source_world, instanceSourcePositions64Low);\ntarget = project_position(target_world, instanceTargetPositions64Low);\nfloat antiMeridianX = 0.0;\nif (arc.useShortestPath) {\nif (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET) {\nantiMeridianX = -(project.coordinateOrigin.x + 180.) / 360. * TILE_SIZE;\n}\nfloat thresholdRatio = (antiMeridianX - source.x) / (target.x - source.x);\nif (prevSegmentRatio <= thresholdRatio && nextSegmentRatio > thresholdRatio) {\nisValid = 0.0;\nindexDir = sign(segmentRatio - thresholdRatio);\nsegmentRatio = thresholdRatio;\n}\n}\nnextSegmentRatio = indexDir < 0.0 ? prevSegmentRatio : nextSegmentRatio;\nvec3 currPos = interpolateFlat(source, target, segmentRatio);\nvec3 nextPos = interpolateFlat(source, target, nextSegmentRatio);\nif (arc.useShortestPath) {\nif (nextPos.x < antiMeridianX) {\ncurrPos.x += TILE_SIZE;\nnextPos.x += TILE_SIZE;\n}\n}\ncurr = project_common_position_to_clipspace(vec4(currPos, 1.0));\nnext = project_common_position_to_clipspace(vec4(nextPos, 1.0));\ngeometry.position = vec4(currPos, 1.0);\n}\nfloat widthPixels = clamp(\nproject_size_to_pixel(instanceWidths * arc.widthScale, arc.widthUnits),\narc.widthMinPixels, arc.widthMaxPixels\n);\nvec3 offset = vec3(\ngetExtrusionOffset((next.xy - curr.xy) * indexDir, segmentSide, widthPixels),\n0.0);\nDECKGL_FILTER_SIZE(offset, geometry);\nDECKGL_FILTER_GL_POSITION(curr, geometry);\ngl_Position = curr + vec4(project_pixel_size_to_clipspace(offset.xy), 0.0, 0.0);\nvec4 color = mix(instanceSourceColors, instanceTargetColors, segmentRatio);\nvColor = vec4(color.rgb, color.a * layer.opacity);\nDECKGL_FILTER_COLOR(vColor, geometry);\n}\n",fs:"#version 300 es\n#define SHADER_NAME arc-layer-fragment-shader\nprecision highp float;\nin vec4 vColor;\nin vec2 uv;\nin float isValid;\nout vec4 fragColor;\nvoid main(void) {\nif (isValid == 0.0) {\ndiscard;\n}\nfragColor = vColor;\ngeometry.uv = uv;\nDECKGL_FILTER_COLOR(fragColor, geometry);\n}\n",modules:[r.A,i.A,u]})}get wrapLongitude(){return!1}initializeState(){this.getAttributeManager().addInstanced({instanceSourcePositions:{size:3,type:"float64",fp64:this.use64bitPositions(),transition:!0,accessor:"getSourcePosition"},instanceTargetPositions:{size:3,type:"float64",fp64:this.use64bitPositions(),transition:!0,accessor:"getTargetPosition"},instanceSourceColors:{size:this.props.colorFormat.length,type:"unorm8",transition:!0,accessor:"getSourceColor",defaultValue:d},instanceTargetColors:{size:this.props.colorFormat.length,type:"unorm8",transition:!0,accessor:"getTargetColor",defaultValue:d},instanceWidths:{size:1,transition:!0,accessor:"getWidth",defaultValue:1},instanceHeights:{size:1,transition:!0,accessor:"getHeight",defaultValue:1},instanceTilts:{size:1,transition:!0,accessor:"getTilt",defaultValue:0}})}updateState(t){super.updateState(t),t.changeFlags.extensionsChanged&&(this.state.model?.destroy(),this.state.model=this._getModel(),this.getAttributeManager().invalidateAll())}draw({uniforms:t}){const{widthUnits:e,widthScale:o,widthMinPixels:n,widthMaxPixels:a,greatCircle:r,wrapLongitude:i,numSegments:c}=this.props,l={numSegments:c,widthUnits:s.p5[e],widthScale:o,widthMinPixels:n,widthMaxPixels:a,greatCircle:r,useShortestPath:i},u=this.state.model;u.shaderInputs.setProps({arc:l}),u.setVertexCount(2*c),u.draw(this.context.renderPass)}_getModel(){return new c.K(this.context.device,{...this.getShaders(),id:this.props.id,bufferLayout:this.getAttributeManager().getBufferLayouts(),topology:"triangle-strip",isInstanced:!0})}}p.layerName="ArcLayer",p.defaultProps=g;const f=p;var m=o(92123),h=o(83860),x=o(832),_=o(42828),v=o(51316);function P(t){const e=[];return t.forEach(t=>{e.push(t.sourcePosition),e.push(t.targetPosition)}),e}function y(t){return(0,_.j1)(t,t=>(0,n.FD)("div",{className:"deckgl-tooltip",children:[_.EO.arcPositions(t),_.EO.category(t)]}))}const S=function({formData:t,payload:e,setTooltip:o,filterState:n,setDataMask:a,onContextMenu:r,emitCrossFilters:i}){const s=t,c=e.data.features,l=s.color_picker,u=s.target_color_picker,d=s.color_scheme_type;return new f({data:c,getSourceColor:t=>d===m.wP.fixed_color?[l.r,l.g,l.b,255*l.a]:t.sourceColor||t.color||[l.r,l.g,l.b,255*l.a],getTargetColor:t=>d===m.wP.fixed_color?[u.r,u.g,u.b,255*u.a]:t.targetColor||t.color||[u.r,u.g,u.b,255*u.a],id:`path-layer-${s.slice_id}`,getWidth:s.stroke_width?s.stroke_width:3,...(0,h.T$)({formData:s,setTooltip:o,setTooltipContent:y(s),onContextMenu:r,setDataMask:a,filterState:n,emitCrossFilters:i}),opacity:null!=n&&n.value?.1:1})},w=function({formData:t,payload:e,filterState:o}){const n=t,a=e.data.features,r=t=>{const e=null==o?void 0:o.value[0],n=null==o?void 0:o.value[1];return e&&n&&t.sourcePosition[0]===e[0]&&t.sourcePosition[1]===e[1]&&t.targetPosition[0]===n[0]&&t.targetPosition[1]===n[1]?v.Fe:v.LC};return new f({data:a,getSourceColor:r,getTargetColor:r,id:`path-hihglight-layer-${n.slice_id}`,getWidth:n.stroke_width?n.stroke_width:3})},C=(0,x.c)(S,P,w)}}]);