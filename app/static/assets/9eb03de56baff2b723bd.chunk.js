"use strict";(globalThis.webpackChunksuperset=globalThis.webpackChunksuperset||[]).push([[4097,5087],{15087:(t,e,s)=>{s.r(e),s.d(e,{default:()=>M});const i=[Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array];class r{static from(t){if(!(t instanceof ArrayBuffer))throw new Error("Data must be an instance of ArrayBuffer.");const[e,s]=new Uint8Array(t,0,2);if(219!==e)throw new Error("Data does not appear to be in a KDBush format.");const o=s>>4;if(1!==o)throw new Error(`Got v${o} data when expected v1.`);const n=i[15&s];if(!n)throw new Error("Unrecognized array type.");const[a]=new Uint16Array(t,2,1),[h]=new Uint32Array(t,4,1);return new r(h,a,n,t)}constructor(t,e=64,s=Float64Array,r){if(isNaN(t)||t<0)throw new Error(`Unpexpected numItems value: ${t}.`);this.numItems=+t,this.nodeSize=Math.min(Math.max(+e,2),65535),this.ArrayType=s,this.IndexArrayType=t<65536?Uint16Array:Uint32Array;const o=i.indexOf(this.ArrayType),n=2*t*this.ArrayType.BYTES_PER_ELEMENT,a=t*this.IndexArrayType.BYTES_PER_ELEMENT,h=(8-a%8)%8;if(o<0)throw new Error(`Unexpected typed array class: ${s}.`);r&&r instanceof ArrayBuffer?(this.data=r,this.ids=new this.IndexArrayType(this.data,8,t),this.coords=new this.ArrayType(this.data,8+a+h,2*t),this._pos=2*t,this._finished=!0):(this.data=new ArrayBuffer(8+n+a+h),this.ids=new this.IndexArrayType(this.data,8,t),this.coords=new this.ArrayType(this.data,8+a+h,2*t),this._pos=0,this._finished=!1,new Uint8Array(this.data,0,2).set([219,16+o]),new Uint16Array(this.data,2,1)[0]=e,new Uint32Array(this.data,4,1)[0]=t)}add(t,e){const s=this._pos>>1;return this.ids[s]=s,this.coords[this._pos++]=t,this.coords[this._pos++]=e,s}finish(){const t=this._pos>>1;if(t!==this.numItems)throw new Error(`Added ${t} items when expected ${this.numItems}.`);return o(this.ids,this.coords,this.nodeSize,0,this.numItems-1,0),this._finished=!0,this}range(t,e,s,i){if(!this._finished)throw new Error("Data not yet indexed - call index.finish().");const{ids:r,coords:o,nodeSize:n}=this,a=[0,r.length-1,0],h=[];for(;a.length;){const u=a.pop()||0,d=a.pop()||0,c=a.pop()||0;if(d-c<=n){for(let n=c;n<=d;n++){const a=o[2*n],u=o[2*n+1];a>=t&&a<=s&&u>=e&&u<=i&&h.push(r[n])}continue}const p=c+d>>1,l=o[2*p],g=o[2*p+1];l>=t&&l<=s&&g>=e&&g<=i&&h.push(r[p]),(0===u?t<=l:e<=g)&&(a.push(c),a.push(p-1),a.push(1-u)),(0===u?s>=l:i>=g)&&(a.push(p+1),a.push(d),a.push(1-u))}return h}within(t,e,s){if(!this._finished)throw new Error("Data not yet indexed - call index.finish().");const{ids:i,coords:r,nodeSize:o}=this,n=[0,i.length-1,0],a=[],h=s*s;for(;n.length;){const d=n.pop()||0,c=n.pop()||0,p=n.pop()||0;if(c-p<=o){for(let s=p;s<=c;s++)u(r[2*s],r[2*s+1],t,e)<=h&&a.push(i[s]);continue}const l=p+c>>1,g=r[2*l],m=r[2*l+1];u(g,m,t,e)<=h&&a.push(i[l]),(0===d?t-s<=g:e-s<=m)&&(n.push(p),n.push(l-1),n.push(1-d)),(0===d?t+s>=g:e+s>=m)&&(n.push(l+1),n.push(c),n.push(1-d))}return a}}function o(t,e,s,i,r,a){if(r-i<=s)return;const h=i+r>>1;n(t,e,h,i,r,a),o(t,e,s,i,h-1,1-a),o(t,e,s,h+1,r,1-a)}function n(t,e,s,i,r,o){for(;r>i;){if(r-i>600){const a=r-i+1,h=s-i+1,u=Math.log(a),d=.5*Math.exp(2*u/3),c=.5*Math.sqrt(u*d*(a-d)/a)*(h-a/2<0?-1:1);n(t,e,s,Math.max(i,Math.floor(s-h*d/a+c)),Math.min(r,Math.floor(s+(a-h)*d/a+c)),o)}const h=e[2*s+o];let u=i,d=r;for(a(t,e,i,s),e[2*r+o]>h&&a(t,e,i,r);u<d;){for(a(t,e,u,d),u++,d--;e[2*u+o]<h;)u++;for(;e[2*d+o]>h;)d--}e[2*i+o]===h?a(t,e,i,d):(d++,a(t,e,d,r)),d<=s&&(i=d+1),s<=d&&(r=d-1)}}function a(t,e,s,i){h(t,s,i),h(e,2*s,2*i),h(e,2*s+1,2*i+1)}function h(t,e,s){const i=t[e];t[e]=t[s],t[s]=i}function u(t,e,s,i){const r=t-s,o=e-i;return r*r+o*o}const d={minZoom:0,maxZoom:16,minPoints:2,radius:40,extent:512,nodeSize:64,log:!1,generateId:!1,reduce:null,map:t=>t},c=Math.fround||(p=new Float32Array(1),t=>(p[0]=+t,p[0]));var p;class l{constructor(t){this.options=Object.assign(Object.create(d),t),this.trees=new Array(this.options.maxZoom+1),this.stride=this.options.reduce?7:6,this.clusterProps=[]}load(t){const{log:e,minZoom:s,maxZoom:i}=this.options;e&&console.time("total time");const r=`prepare ${t.length} points`;e&&console.time(r),this.points=t;const o=[];for(let e=0;e<t.length;e++){const s=t[e];if(!s.geometry)continue;const[i,r]=s.geometry.coordinates,n=c(f(i)),a=c(w(r));o.push(n,a,1/0,e,-1,1),this.options.reduce&&o.push(0)}let n=this.trees[i+1]=this._createTree(o);e&&console.timeEnd(r);for(let t=i;t>=s;t--){const s=+Date.now();n=this.trees[t]=this._createTree(this._cluster(n,t)),e&&console.log("z%d: %d clusters in %dms",t,n.numItems,+Date.now()-s)}return e&&console.timeEnd("total time"),this}getClusters(t,e){let s=((t[0]+180)%360+360)%360-180;const i=Math.max(-90,Math.min(90,t[1]));let r=180===t[2]?180:((t[2]+180)%360+360)%360-180;const o=Math.max(-90,Math.min(90,t[3]));if(t[2]-t[0]>=360)s=-180,r=180;else if(s>r){const t=this.getClusters([s,i,180,o],e),n=this.getClusters([-180,i,r,o],e);return t.concat(n)}const n=this.trees[this._limitZoom(e)],a=n.range(f(s),w(o),f(r),w(i)),h=n.data,u=[];for(const t of a){const e=this.stride*t;u.push(h[e+5]>1?g(h,e,this.clusterProps):this.points[h[e+3]])}return u}getChildren(t){const e=this._getOriginId(t),s=this._getOriginZoom(t),i="No cluster with the specified id.",r=this.trees[s];if(!r)throw new Error(i);const o=r.data;if(e*this.stride>=o.length)throw new Error(i);const n=this.options.radius/(this.options.extent*Math.pow(2,s-1)),a=o[e*this.stride],h=o[e*this.stride+1],u=r.within(a,h,n),d=[];for(const e of u){const s=e*this.stride;o[s+4]===t&&d.push(o[s+5]>1?g(o,s,this.clusterProps):this.points[o[s+3]])}if(0===d.length)throw new Error(i);return d}getLeaves(t,e,s){e=e||10,s=s||0;const i=[];return this._appendLeaves(i,t,e,s,0),i}getTile(t,e,s){const i=this.trees[this._limitZoom(t)],r=Math.pow(2,t),{extent:o,radius:n}=this.options,a=n/o,h=(s-a)/r,u=(s+1+a)/r,d={features:[]};return this._addTileFeatures(i.range((e-a)/r,h,(e+1+a)/r,u),i.data,e,s,r,d),0===e&&this._addTileFeatures(i.range(1-a/r,h,1,u),i.data,r,s,r,d),e===r-1&&this._addTileFeatures(i.range(0,h,a/r,u),i.data,-1,s,r,d),d.features.length?d:null}getClusterExpansionZoom(t){let e=this._getOriginZoom(t)-1;for(;e<=this.options.maxZoom;){const s=this.getChildren(t);if(e++,1!==s.length)break;t=s[0].properties.cluster_id}return e}_appendLeaves(t,e,s,i,r){const o=this.getChildren(e);for(const e of o){const o=e.properties;if(o&&o.cluster?r+o.point_count<=i?r+=o.point_count:r=this._appendLeaves(t,o.cluster_id,s,i,r):r<i?r++:t.push(e),t.length===s)break}return r}_createTree(t){const e=new r(t.length/this.stride|0,this.options.nodeSize,Float32Array);for(let s=0;s<t.length;s+=this.stride)e.add(t[s],t[s+1]);return e.finish(),e.data=t,e}_addTileFeatures(t,e,s,i,r,o){for(const n of t){const t=n*this.stride,a=e[t+5]>1;let h,u,d;if(a)h=m(e,t,this.clusterProps),u=e[t],d=e[t+1];else{const s=this.points[e[t+3]];h=s.properties;const[i,r]=s.geometry.coordinates;u=f(i),d=w(r)}const c={type:1,geometry:[[Math.round(this.options.extent*(u*r-s)),Math.round(this.options.extent*(d*r-i))]],tags:h};let p;p=a||this.options.generateId?e[t+3]:this.points[e[t+3]].id,void 0!==p&&(c.id=p),o.features.push(c)}}_limitZoom(t){return Math.max(this.options.minZoom,Math.min(Math.floor(+t),this.options.maxZoom+1))}_cluster(t,e){const{radius:s,extent:i,reduce:r,minPoints:o}=this.options,n=s/(i*Math.pow(2,e)),a=t.data,h=[],u=this.stride;for(let s=0;s<a.length;s+=u){if(a[s+2]<=e)continue;a[s+2]=e;const i=a[s],d=a[s+1],c=t.within(a[s],a[s+1],n),p=a[s+5];let l=p;for(const t of c){const s=t*u;a[s+2]>e&&(l+=a[s+5])}if(l>p&&l>=o){let t,o=i*p,n=d*p,g=-1;const m=(s/u<<5)+(e+1)+this.points.length;for(const i of c){const h=i*u;if(a[h+2]<=e)continue;a[h+2]=e;const d=a[h+5];o+=a[h]*d,n+=a[h+1]*d,a[h+4]=m,r&&(t||(t=this._map(a,s,!0),g=this.clusterProps.length,this.clusterProps.push(t)),r(t,this._map(a,h)))}a[s+4]=m,h.push(o/l,n/l,1/0,m,-1,l),r&&h.push(g)}else{for(let t=0;t<u;t++)h.push(a[s+t]);if(l>1)for(const t of c){const s=t*u;if(!(a[s+2]<=e)){a[s+2]=e;for(let t=0;t<u;t++)h.push(a[s+t])}}}}return h}_getOriginId(t){return t-this.points.length>>5}_getOriginZoom(t){return(t-this.points.length)%32}_map(t,e,s){if(t[e+5]>1){const i=this.clusterProps[t[e+6]];return s?Object.assign({},i):i}const i=this.points[t[e+3]].properties,r=this.options.map(i);return s&&r===i?Object.assign({},r):r}}function g(t,e,s){return{type:"Feature",id:t[e+3],properties:m(t,e,s),geometry:{type:"Point",coordinates:[(i=t[e],360*(i-.5)),y(t[e+1])]}};var i}function m(t,e,s){const i=t[e+5],r=i>=1e4?`${Math.round(i/1e3)}k`:i>=1e3?Math.round(i/100)/10+"k":i,o=t[e+6],n=-1===o?{}:Object.assign({},s[o]);return Object.assign(n,{cluster:!0,cluster_id:t[e+3],point_count:i,point_count_abbreviated:r})}function f(t){return t/360+.5}function w(t){const e=Math.sin(t*Math.PI/180),s=.5-.25*Math.log((1+e)/(1-e))/Math.PI;return s<0?0:s>1?1:s}function y(t){const e=(180-360*t)*Math.PI/180;return 360*Math.atan(Math.exp(e))/Math.PI-90}var b=s(24097);const x=()=>{};function M(t){const{width:e,height:s,formData:i,hooks:r,queriesData:o}=t,{onError:n=x,setControlValue:a=x}=r,{bounds:h,geoJSON:u,hasCustomMetric:d,mapboxApiKey:c}=o[0].data,{clusteringRadius:p,globalOpacity:g,mapboxColor:m,mapboxStyle:f,pandasAggfunc:w,pointRadius:y,pointRadiusUnit:M,renderWhileDragging:_}=i,A=/^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/.exec(m);if(null===A)return n("Color field must be of form 'rgb(%d, %d, %d)'"),{};const T={maxZoom:b.DEFAULT_MAX_ZOOM,radius:p};d&&(T.initial=()=>({sum:0,squaredSum:0,min:1/0,max:-1/0}),T.map=t=>({sum:t.metric,squaredSum:t.metric**2,min:t.metric,max:t.metric}),T.reduce=(t,e)=>{t.sum+=e.sum,t.squaredSum+=e.squaredSum,t.min=Math.min(t.min,e.min),t.max=Math.max(t.max,e.max)});const C=new l(T);return C.load(u.features),{width:e,height:s,aggregatorName:w,bounds:h,clusterer:C,globalOpacity:g,hasCustomMetric:d,mapboxApiKey:c,mapStyle:f,onViewportChange({latitude:t,longitude:e,zoom:s}){a("viewport_longitude",e),a("viewport_latitude",t),a("viewport_zoom",s)},pointRadius:"Auto"===y?b.DEFAULT_POINT_RADIUS:y,pointRadiusUnit:M,renderWhileDragging:_,rgb:A}}},24097:(t,e,s)=>{s.r(e),s.d(e,{DEFAULT_MAX_ZOOM:()=>g,DEFAULT_POINT_RADIUS:()=>m,default:()=>b});var i=s(24002),r=s(5556),o=s.n(r),n=s(88813),a=s(55016);function h(t,e){let s;if(e){const i=10**e;s=Math.round(t*i)/i}else s=Math.round(t);return s}function u(t,e,s){const i=e*(Math.PI/180);return h(t/(40075.16*Math.cos(i)/2**(s+9)),2)}var d=s(2445);const c={aggregation:o().string,compositeOperation:o().string,dotRadius:o().number,lngLatAccessor:o().func,locations:o().arrayOf(o().object).isRequired,pointRadiusUnit:o().string,renderWhileDragging:o().bool,rgb:o().arrayOf(o().oneOfType([o().string,o().number])),zoom:o().number};class p extends i.PureComponent{constructor(t){super(t),this.redraw=this.redraw.bind(this)}drawText(t,e,s={}){const{fontHeight:i=0,label:r="",radius:o=0,rgb:n=[0,0,0],shadow:a=!1}=s,h=1.8*o,u=.2126*n[1]+.7152*n[2]+.0722*n[3];t.globalCompositeOperation="source-over",t.fillStyle=u<=110?"white":"black",t.font=`${i}px sans-serif`,t.textAlign="center",t.textBaseline="middle",a&&(t.shadowBlur=15,t.shadowColor=u<=110?"black":"");const d=t.measureText(r).width;if(d>h){const e=i/d;t.font=e*h+"px sans-serif"}const{compositeOperation:c}=this.props;t.fillText(r,e[0],e[1]),t.globalCompositeOperation=c,t.shadowBlur=0,t.shadowColor=""}redraw({width:t,height:e,ctx:s,isDragging:i,project:r}){const{aggregation:o,compositeOperation:n,dotRadius:a,lngLatAccessor:d,locations:c,pointRadiusUnit:p,renderWhileDragging:l,rgb:g,zoom:m}=this.props,f=a,w=[];c.forEach((t,e)=>{t.properties.cluster&&(w[e]=((t,e)=>{const s=t.point_count;if(!e)return s;if("sum"===e||"min"===e||"max"===e)return t[e];const{sum:i}=t,r=i/s;if("mean"===e)return Math.round(100*r)/100;const{squaredSum:o}=t,n=o/s-(i/s)**2;return"var"===e?Math.round(100*n)/100:"stdev"===e?Math.round(100*Math.sqrt(n))/100:s})(t.properties,o))},this);const y=Math.max(...w.filter(t=>!Number.isNaN(t)));s.clearRect(0,0,t,e),s.globalCompositeOperation=n,!l&&i||!c||c.forEach(function(i,o){const n=r(d(i)),a=[h(n[0],1),h(n[1],1)];if(a[0]+f>=0&&a[0]-f<t&&a[1]+f>=0&&a[1]-f<e)if(s.beginPath(),i.properties.cluster){let t=w[o];const e=h((t/y)**.5*f,1),i=h(.5*e,1),[r,n]=a,u=s.createRadialGradient(r,n,e,r,n,0);u.addColorStop(1,`rgba(${g[1]}, ${g[2]}, ${g[3]}, 0.8)`),u.addColorStop(0,`rgba(${g[1]}, ${g[2]}, ${g[3]}, 0)`),s.arc(a[0],a[1],e,0,2*Math.PI),s.fillStyle=u,s.fill(),Number.isFinite(parseFloat(t))&&(t>=1e4?t=`${Math.round(t/1e3)}k`:t>=1e3&&(t=Math.round(t/100)/10+"k"),this.drawText(s,a,{fontHeight:i,label:t,radius:e,rgb:g,shadow:!0}))}else{const t=f/6,e=i.properties.radius,r=i.properties.metric;let o,n=null===e?t:e;if(null!==e){const t=d(i)[1];"Kilometers"===p?(o=`${h(n,2)}km`,n=u(n,t,m)):"Miles"===p&&(o=`${h(n,2)}mi`,n=u(1.60934*n,t,m))}null!==r&&(o=Number.isFinite(parseFloat(r))?h(r,2):r),n||(n=t),s.arc(a[0],a[1],h(n,1),0,2*Math.PI),s.fillStyle=`rgb(${g[1]}, ${g[2]}, ${g[3]})`,s.fill(),void 0!==o&&this.drawText(s,a,{fontHeight:h(n,1),label:o,radius:n,rgb:g,shadow:!1})}},this)}render(){return(0,d.Y)(n.Zd,{redraw:this.redraw})}}p.propTypes=c,p.defaultProps={compositeOperation:"source-over",dotRadius:4,lngLatAccessor:t=>[t[0],t[1]],renderWhileDragging:!0};const l=p,g=16,m=60,f={width:o().number,height:o().number,aggregatorName:o().string,clusterer:o().object,globalOpacity:o().number,hasCustomMetric:o().bool,mapStyle:o().string,mapboxApiKey:o().string.isRequired,onViewportChange:o().func,pointRadius:o().number,pointRadiusUnit:o().string,renderWhileDragging:o().bool,rgb:o().array,bounds:o().array},w={width:400,height:400,globalOpacity:1,onViewportChange:()=>{},pointRadius:m,pointRadiusUnit:"Pixels"};class y extends i.Component{constructor(t){super(t);const{width:e,height:s,bounds:i}=this.props,r=new a.KH({width:e,height:s}).fitBounds(i),{latitude:o,longitude:n,zoom:h}=r;this.state={viewport:{longitude:n,latitude:o,zoom:h}},this.handleViewportChange=this.handleViewportChange.bind(this)}handleViewportChange(t){this.setState({viewport:t});const{onViewportChange:e}=this.props;e(t)}render(){const{width:t,height:e,aggregatorName:s,clusterer:i,globalOpacity:r,mapStyle:o,mapboxApiKey:a,pointRadius:h,pointRadiusUnit:u,renderWhileDragging:c,rgb:p,hasCustomMetric:g,bounds:m}=this.props,{viewport:f}=this.state,w=void 0!==f.isDragging&&f.isDragging,y=.5*t/100,b=.5*e/100,x=[m[0][0]-y,m[0][1]-b,m[1][0]+y,m[1][1]+b],M=i.getClusters(x,Math.round(f.zoom));return(0,d.Y)(n.Ay,{...f,mapStyle:o,width:t,height:e,mapboxApiAccessToken:a,onViewportChange:this.handleViewportChange,preserveDrawingBuffer:!0,children:(0,d.Y)(l,{...f,isDragging:w,locations:M,dotRadius:h,pointRadiusUnit:u,rgb:p,globalOpacity:r,compositeOperation:"screen",renderWhileDragging:c,aggregation:g?s:null,lngLatAccessor:t=>{const{coordinates:e}=t.geometry;return[e[0],e[1]]}})})}}y.propTypes=f,y.defaultProps=w;const b=y}}]);